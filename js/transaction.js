const testData = require("../testDataGenerator.js");
const chain = testData.chain;
// this class will create transaction, and validate transactions.
// data structure:
//
let transactionExample = {
    "hash": "A string, generated by the transaction header",
    "header": {
        "ver": "A string, to provide compatibility",
        //signature created by the hash of the body and user's privatekey, 
        "signature": "a string"
    },
    // i will skip the size, in size, out size, and lock 
    "body": {
        // there is not a thing like this in Bitcoin, which I don't know why. I do this to make it easy to understand.
        "from_address": "public key of this sender",
        "in": [
            // there would be multiple ins in order to get enough amount of coin for the output
            // after this transaction, the following outputs would be spended
            {
                "prev_out_hash": "#1 hash string, point to the transaction from where this address reveived some un spend coin",
            }, {
                "prev_out_hash": "#2 hash string, point to the transaction from where this address reveived some un spend coin",
            }, {
                "prev_out_hash": "#3 hash string, point to the transaction from where this address reveived some un spend coin",
            }
        ],
        "out": [
            // there could be multiple receivers
            {
                "address": "receiver's public key",
                "value": "a string of a number, how many coins are gonna be send to this address"
            }, {
                "address": "receiver's public key",
                "value": "a number, how many coins are gonna be send to this address"
            }
        ]
    }
};

// steps to generate a transaction:
// 1 create the transaction body
// 2 generate a hash (sha256, base64)of the transaction body, then sign it with your privatekey coresponding to the from_address
// 3 store the signature and version number in the header
// 4 then generate a hash of the header, store it in the transaction.
// this is my concept, hopefully it  will work, 

class TransactionManager {

    constructor() {
        this.version = "0.1";
    }

    CreateTransaction(privateKey, senderAddress, receiverAddress, value) {
        let tx = {
            "hash": "",
            "header": {
                "ver": this.version,
                //signature created by the hash of the body and user's privatekey, 
                "signature": ""
            },
            // i will skip the size, in size, out size, and lock 
            "body": {
                // there is not a thing like this in Bitcoin, which I don't know why. I do this to make it easy to understand.
                "from_address": senderAddress,
                "in": [],
                "out": [{
                    "address": receiverAddress,
                    "value": value.toString()
                }]
            }
        };
        // firstly, collect enought unspend output from sender
        //need a function from blockchain manager, which will get all unspend outputs of this sender from blockchain.
        let unspendOuts = chain.GetUnspendOutputsByAddress(senderAddress);
        let valueCollected = 0;
        let prevOuts = [];
        for (let i = 0; i < unspendOuts.length; i++) {
            prevOuts.push(unspendOuts[i]);
            valueCollected += parseFloat(unspendOuts[i].value);
            if (valueCollected >= value) break;
        }
        for (let i = 0; i < prevOuts.length; i++) {
            tx.body.in.push({
                "prev_out_hash": prevOuts[i].tx_hash
            });
        }
        return tx;
    }
}

let txManager = new TransactionManager();

module.exports = txManager;
