const testData = require("../testDataGenerator.js");
const chain = testData.chain;

const crypto = require("crypto");

// this class will create transaction, and validate transactions.
// data structure:
//
let transactionExample = {
    "hash": "A string, generated by the transaction header",
    "header": {
        "ver": "A string, to provide compatibility",
        //signature created by the hash of the body and user's privatekey, 
        "signature": "a string"
    },
    // i will skip the size, in size, out size, and lock 
    "body": {
        // there is not a thing like this in Bitcoin, which I don't know why. I do this to make it easy to understand.
        "from_address": "public key of this sender",
        "in": [
            // there would be multiple ins in order to get enough amount of coin for the output
            // after this transaction, the following outputs would be spended
            {
                "prev_out_hash": "#1 hash string, point to the transaction from where this address reveived some un spend coin",
            }, {
                "prev_out_hash": "#2 hash string, point to the transaction from where this address reveived some un spend coin",
            }, {
                "prev_out_hash": "#3 hash string, point to the transaction from where this address reveived some un spend coin",
            }
        ],
        "out": [
            // there could be multiple receivers
            {
                "address": "receiver's public key",
                "value": "a string of a number, how many coins are gonna be send to this address"
            }, {
                "address": "receiver's public key",
                "value": "a number, how many coins are gonna be send to this address"
            }
        ]
    }
};

// steps to generate a transaction:
// 1 create the transaction body
// 2 generate a hash (sha256, base64)of the transaction body, then sign it with your privatekey coresponding to the from_address
// 3 store the signature and version number in the header
// 4 then generate a hash of the header, store it in the transaction.
// this is my concept, hopefully it  will work, 

class TransactionManager {

    constructor() {
        this.version = "0.1";
    }

    CreateTransaction(privateKey, senderAddress, receiverAddress, value) {
        let signer = crypto.createSign('SHA256');
        let bodyHasher = crypto.createHash('SHA256');
        let headerHasher = crypto.createHash('SHA256');
        let verify = crypto.createVerify('SHA256');
        let tx = {
            "hash": "",
            "header": {
                "ver": this.version,
                //signature created by the hash of the body and user's privatekey, 
                "signature": ""
            },
            // i will skip the size, in size, out size, and lock 
            "body": {
                // there is not a thing like this in Bitcoin, which I don't know why. I do this to make it easy to understand.
                "from_address": senderAddress,
                "in": [],
                "out": [{
                    "address": receiverAddress,
                    "value": value.toString()
                }]
            }
        };
        // firstly, collect enought unspend output from sender
        //need a function from blockchain manager, which will get all unspend outputs of this sender from blockchain.
        let unspendOuts = chain.GetUnspendOutputsByAddress(senderAddress);
        let valueCollected = 0;
        let prevOuts = [];
        for (let i = 0; i < unspendOuts.length; i++) {
            prevOuts.push(unspendOuts[i]);
            valueCollected += parseFloat(unspendOuts[i].value);
            if (valueCollected >= value) break;
        }
        for (let i = 0; i < prevOuts.length; i++) {
            tx.body.in.push({
                "prev_out_hash": prevOuts[i].tx_hash
            });
        }

        // culculate refund amount.
        // if total prev_out is larger than needed, creat a refund output/
        if (valueCollected > value) {
            let refundOutput = {
                "address": senderAddress,
                "value": (valueCollected - value).toString()
            };
            tx.body.out.push(refundOutput);
        }

        //hash the body;
        bodyHasher.update(JSON.stringify(tx.body));
        let bodyHash = bodyHasher.digest('base64');
        // sign the bodyhash use sender's private key;
        signer.update(bodyHash);
        let signature = signer.sign(privateKey, 'base64');

        // write it to header
        tx.header.signature = signature;

        // hash the header, store it to tx
        headerHasher.update(JSON.stringify(tx.header));
        tx.hash = headerHasher.digest('base64');

        return tx;
    }

    VerifyTransaction(tx) {
        let bodyHasher = crypto.createHash('SHA256');
        let headerHasher = crypto.createHash('SHA256');
        let verifier = crypto.createVerify('SHA256');
        //hash the body, then compare the signature, sender address, body hash
        bodyHasher.update(JSON.stringify(tx.body));
        let bodyHash = bodyHasher.digest('base64');

        verifier.update(bodyHash);
        let signatureValidity = verifier.verify(tx.body.from_address, tx.header.signature, 'base64');

        let sigValidityText = signatureValidity ? `the signature is valid` : `the signature is invalid, INVALID!!!`;
        console.log(sigValidityText);

        //hash the header, see if header has changed
        headerHasher.update(JSON.stringify(tx.header));
        let headerHash = headerHasher.digest('base64');
        let headerConsistency = headerHash === tx.hash ? true : false;
        let headerConsisText = headerConsistency ? `the header hash matchs` : `the header hash does't match!!!`;
        console.log(headerConsisText);

        // return the resault
        if (signatureValidity && headerConsistency) {
            console.log('the signature matchs the body Hash and the sender address, and the hash matchs the header hash');
            return true;
        } else {
            console.log(`something changed here`);
            return false;
        }
    }
}

let txManager = new TransactionManager();

module.exports = txManager;
